<?php namespace ProcessWire;

/**
 * ProcessUserDataTable.module
 *
 * Displays a configurable table of user fields in the ProcessWire admin interface.
 *
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 *
 * @author frameless Media
 * @link   https://frameless.at
 * @license GNU/GPL v2
 * @version 2.4.0
 */

class ProcessUserDataTable extends Process implements Module, ConfigurableModule {

	/**
	 * Get module information.
	 *
	 * @return array
	 */
	public static function getModuleInfo(): array {
		return [
			'title' => 'User Data Table',
			'version' => '2.4.0',
			'summary' => 'Displays a configurable table of user fields in the admin interface.',
			'author' => 'frameless Media',
			'icon' => 'users',
			'singular' => true,
			'autoload' => false,
			'permission' => 'user-admin',
			'page' => [
				'name' => 'user-data-table',
				'title' => 'User Data Table'
			]
		];
	}

	/** @var array Holds the table columns configuration */
	protected $columns = [];

	/**
	 * Main execute method to render the table.
	 *
	 * @return string Rendered HTML table
	 */
	public function ___execute(): string {
		$data = $this->modules->getModuleConfigData($this);
		$fieldList = json_decode($data['user_fields'] ?? '[]', true);
		if (!is_array($fieldList)) $fieldList = [];

		$this->columns = [];
		foreach ($fieldList as $fieldName) {
			$this->columns[] = [
				'user_field' => $fieldName,
				'parameters' => $data['param__' . $fieldName] ?? ''
			];
		}

		return $this->renderTable($data);
	}

			 
	/**
	 * Parse configuration parameters from a multiline text string.
	 *
	 * Processes key-value pairs from a string where each line contains one parameter.
	 * Ignores lines marked as optional (e.g., "key=value (optional)").
	 *
	 * Example input:
	 *  key1=value1
	 *  key2=value2 (optional)
	 *
	 * @param string $text The raw parameter string with one key=value pair per line
	 * @return array An associative array of parsed parameters
	 */
	
	protected function parseParams(string $text): array {
		$lines = explode("\n", $text); // Split the input into lines
		$params = [];
		
		foreach ($lines as $line) {
			// Match key-value pairs with a simple syntax
			if (preg_match('/^([a-zA-Z0-9_]+)=(.+)$/', $line, $matches)) {
				$key = trim($matches[1]);
				$val = trim($matches[2]);
	
				// Skip parameters with "(optional)" in their value
				if (str_ends_with($val, '(optional)')) {
					continue;
				}
				$params[$key] = $val; // Add the key-value pair
			}
		}
		return $params; // Return all parsed parameters
	}

	
	/**
	 * Centralized method to format values.
	 *
	 * Handles various formats such as integers, numbers, currency, percentages,
	 * and custom patterns. Supports localization for currency formatting.
	 *
	 * @param mixed $value The value to format.
	 * @param array $params Additional parameters to customize formatting, including:
	 *  - 'format': The desired format (e.g., 'int', 'number', 'currency=USD', 'percent', 'custom=...').
	 *  - 'locale': (Optional) Locale for currency or localized formatting (e.g., 'en_US', 'de_DE').
	 * @return string The formatted value as a string.
	 */
 	protected function formatValue($value, array $params = []): string {
		 // Fetch the format from parameters
		 $format = trim($params['format'] ?? '');
	 
		 // Handle null or empty values
		 if ($value === null || $value === '') {
			 return '–';
		 }
	 
		 // Handle other formats (e.g., int, number, currency, date, map, etc.)
		 switch (true) {
			 case $format === 'int':
				 return (string) round($value);
	 
			 case $format === 'number':
				 return number_format((float) $value, 2, ',', '');

			case preg_match('/^currency\(([^:]+):(.+)\)$/', $format, $matches):
				$currencyCode = trim($matches[1]);
				$locale = trim($matches[2]);
			
				$formatter = new \NumberFormatter($locale, \NumberFormatter::CURRENCY);
			
				if ((float) $value === 0.0) {
					return '–';
				}

				$formattedValue = $formatter->formatCurrency((float) $value, $currencyCode) ?: (string) $value;
				return preg_replace('/(\p{Sc})(\S)/u', '$1 $2', $formattedValue);	 
				
			 case preg_match('/^date\((.+)\)$/', $format, $matches):
				 $dateFormat = $matches[1];
	 
				 if (is_numeric($value)) {
					 return date($dateFormat, (int) $value);
				 } elseif (is_string($value)) {
					 $timestamp = strtotime($value);
	 
					 // Handle "H:i" time-only formats
					 if ($timestamp === false && preg_match('/^[0-9]{1,2}:[0-9]{2}$/', $value)) {
						 $timestamp = strtotime(date('Y-m-d') . ' ' . $value);
					 }
	 
					 return $timestamp ? date($dateFormat, $timestamp) : (string) $value;
				 }
				 break;
	 
			 case preg_match('/^map\((.+)\)$/', $format, $matches):
				 $mappingString = $matches[1];
				 $mappings = [];
	 
				 // Process key-value pairs
				 $pairs = explode(',', $mappingString);
				 foreach ($pairs as $pair) {
					 if (strpos($pair, ':') !== false) {
						 list($key, $label) = explode(':', $pair, 2);
						 $mappings[trim($key)] = trim($label);
					 }
				 }
	 
				 // Return the mapped label if it exists
				 return $mappings[(string) $value] ?? (string) $value;
				 
			 case $format === 'percent':
				 return round((float) $value * 100) . ' %';
	 
			 case strpos($format, 'custom=') === 0:
				 $pattern = substr($format, 7);
				 return sprintf($pattern, $value);
	 
			 default:
				 return $this->sanitizer->entities((string) $value);
		 }
	 }


	/**
	 * Generate a tooltip attribute based on the provided raw value and parameters.
	 *
	 * Applies optional formatting (`tooltip_format`) and a prefix (`tooltip_prefix`) to the tooltip content.
	 * Returns a `data-uk-tooltip` attribute with the formatted tooltip text.
	 *
	 * Example parameters:
	 * - tooltip_format: "date(d.m.Y H:i)"
	 * - tooltip_prefix: "Created on"
	 *
	 * @param mixed $rawValue The raw value to be formatted for the tooltip
	 * @param array $params Configuration parameters, including format and prefix
	 * @return string The generated `data-uk-tooltip` attribute or an empty string if no tooltip is set
	 */
	protected function renderTooltipValue($rawValue, array $params): string {
		// Return early if no value is provided
		if ($rawValue === null || $rawValue === '') return '';
	
		// Extract formatting-specific parameters for formatValue()
		$formatParams = [
			'format' => $params['tooltip_format'] ?? '',
		];
	
		// Use formatValue() to format the raw value
		$formattedValue = $this->formatValue($rawValue, $formatParams);
	
		// Handle tooltip-specific logic (e.g., adding a prefix)
		$prefix = trim($params['tooltip_prefix'] ?? '');
		$tooltipText = $prefix !== '' ? "{$prefix} {$formattedValue}" : $formattedValue;
	
		// Sanitize the output
		$sanitizedTooltip = $this->sanitizer->entities($tooltipText);
	
		// Return the tooltip-specific HTML
		return " data-uk-tooltip title=\"{$sanitizedTooltip}\"";
	}

  
  /**
   * Renders a modal link with entry count and modal content.
   *
   * @param TableRows|null $tableRows - The table rows data.
   * @param array $params - Configuration parameters.
   * @param string $fieldName - The field name.
   * @return string - The rendered modal link and content or an empty string.
   */
  protected function renderModal($tableRows, array $params, string $fieldName): string {
	  $modalEnabled = isset($params['modal']) && $params['modal'] == '1';
	  if (!$modalEnabled || !$tableRows) return '';
  
	  $modalSort = $params['modal_sort'] ?? '';
	  $modalSortDir = strtolower($params['modal_sortdir'] ?? 'asc');
	  $resolvePageColumn = $params['table_column'] ?? '';
	  $resolveField = $params['resolve_page'] ?? '';
	  $modalLabel = $params['label'] ?? 'Details';
  
	  $validSortDir = in_array($modalSortDir, ['asc', 'desc']) ? $modalSortDir : 'asc';
  
	  // Generate unique modal ID
	  $modalId = 'modal-' . uniqid();
	  $entryCount = count($tableRows);
  
	  if ($entryCount === 0) return '';
  
	  $columnLabels = $this->getModalColumnLabels($fieldName);
  
	  // Sorting Logic
	  $this->applyModalSorting($tableRows, $modalSort, $validSortDir);
  
	  // Generate Modal Content
	  $tableContent = $this->generateModalTableContent($tableRows, $resolvePageColumn, $resolveField);
  
	  // Modal Link
	  $link = "<a href='#{$modalId}' uk-toggle>{$entryCount}</a>";
  
	  // Modal Structure
	  $modalContent = "<div id='{$modalId}' class='uk-modal' uk-modal>
						  <div class='uk-modal-dialog uk-modal-body'>
							  <button class='uk-modal-close-default' type='button' uk-close></button>
							  <h2 class='uk-modal-title'>{$modalLabel}</h2>
							  <table class='uk-table uk-table-divider'>
								  <thead>
									  <tr>{$this->generateModalTableHeaders($columnLabels, $tableRows)}</tr>
								  </thead>
								  <tbody>{$tableContent}</tbody>
							  </table>
						  </div>
					  </div>";
  
	  return $link . $modalContent;
  }
  
  /**
   * Extracts and returns column labels for a FieldtypeTable field.
   *
   * @param string $fieldName - The field name.
   * @return array - Array of column labels.
   */
  protected function getModalColumnLabels(string $fieldName): array {
	  $columnLabels = [];
	  $field = $this->wire('fields')->get($fieldName);
  
	  if ($field && isset($field->data['maxCols'])) {
		  $data = $field->data;
		  $maxCols = (int) $data['maxCols'];
  
		  for ($i = 1; $i <= $maxCols; $i++) {
			  $colName = $data["col{$i}name"] ?? null;
			  $colLabel = $data["col{$i}label"] ?? strtoupper($colName);
  
			  if ($colName) {
				  $columnLabels[$colName] = $colLabel;
			  }
		  }
	  }
  
	  return $columnLabels;
  }
  
  /**
   * Applies sorting to the TableRows object for modal display.
   *
   * @param TableRows $tableRows - The table rows.
   * @param string $sortColumn - The column to sort by.
   * @param string $sortDir - The sort direction ('asc' or 'desc').
   */
  protected function applyModalSorting(&$tableRows, string $sortColumn, string $sortDir): void {
	  if ($sortColumn) {
		  $tableRows = iterator_to_array($tableRows);
		  usort($tableRows, function ($a, $b) use ($sortColumn, $sortDir) {
			  $aVal = $a[$sortColumn] ?? '';
			  $bVal = $b[$sortColumn] ?? '';
			  return $sortDir === 'asc' ? $aVal <=> $bVal : $bVal <=> $aVal;
		  });
	  }
  }
  
  /**
   * Generates the table headers for the modal using column labels.
   *
   * @param array $columnLabels - Column labels.
   * @param TableRows $tableRows - The table rows data.
   * @return string - The generated headers HTML.
   */
  protected function generateModalTableHeaders(array $columnLabels, $tableRows): string {
	  $headersHtml = '';
  
	  if (count($tableRows) > 0) {
		  $firstRow = $tableRows[0]->getArray();
		  $headers = array_slice(array_keys($firstRow), 1);
  
		  foreach ($headers as $header) {
			  $label = $columnLabels[$header] ?? strtoupper($header);
			  $headersHtml .= "<th>{$label}</th>";
		  }
	  }
  
	  return $headersHtml;
  }
  
  /**
   * Generates the table content for the modal.
   *
   * @param TableRows $tableRows - The table rows.
   * @param string $resolvePageColumn - Column name to resolve as page link.
   * @param string $resolveField - Field to display for resolved page.
   * @return string - The generated content HTML.
   */
  protected function generateModalTableContent($tableRows, string $resolvePageColumn, string $resolveField): string {
	  $content = '';
  
	  foreach ($tableRows as $row) {
		  $rowArray = $row->getArray();
		  $content .= "<tr>";
  
		  $dataColumns = array_slice($rowArray, 1);
		  foreach ($dataColumns as $key => $value) {
			  if ($key === $resolvePageColumn && $resolveField) {
				  $page = $this->wire('pages')->get((int) $value);
				  $value = $page->id ? "<a href='{$page->url}' target='_blank'>{$page->get($resolveField)}</a>" : 'Unknown';
			  }
			  $content .= "<td>{$value}</td>";
		  }
  
		  $content .= "</tr>";
	  }
  
	  return $content;
  }


	/**
	 * Render a raw table field without Page lookup.
	 *
	 * Processes a table field (FieldtypeTable) by extracting the specified column values,
	 * applying optional formatting, and joining them with a separator.
	 *
	 * @param Page $user The current user object
	 * @param string $fieldName The name of the FieldtypeTable field
	 * @param array $params Configuration parameters, including `table_column`, `separator`, and `format_raw`
	 * @return string The rendered HTML content for the table cell
	 */
	protected function renderTableRawField(Page $user, string $fieldName, array $params): string {
		/** @var WireArray $rows */
		$rows = $user->get($fieldName);
		$column = $params['table_column'] ?? '';
		$separator = $params['separator'] ?? ', ';
		$format = trim($params['format_raw'] ?? '');
		$output = [];
	
		// Ensure the field is a WireArray instance
		if (!($rows instanceof WireArray)) return '';
	
		foreach ($rows as $row) {
			// Skip if the column is not present in the row
			if (!isset($row[$column])) continue;
	
			$value = $row[$column];
	
			// Apply date formatting if specified
			if ($format && is_numeric($value)) {
				$value = date($format, (int) $value);
			}
	
			// Sanitize the output
			$output[] = $this->sanitizer->entities((string) $value);
		}
	
		return implode($separator, $output);
	}
	
	/**
	 * Render a FieldtypeTable field with optional Page reference resolution.
	 *
	 * This method processes a FieldtypeTable field by extracting the specified column values,
	 * optionally resolving Page references, applying tooltips, and formatting the output as a link or plain text.
	 *
	 * @param Page $user The current user object
	 * @param string $fieldName The name of the FieldtypeTable field
	 * @param array $params Configuration parameters, including:
	 *  - `table_column`: The column name in the TableField (required)
	 *  - `resolve_page`: The field to display from the resolved Page object (optional)
	 *  - `as_link`: Display the value as a link to the referenced Page (optional)
	 *  - `tooltip_field`: Column for tooltip content (optional)
	 *  - `tooltip_prefix`: Prefix for the tooltip content (optional)
	 *  - `tooltip_format`: Date format for tooltip content (optional, e.g., `date(d.m.Y H:i)`)
	 *  - `separator`: Separator between multiple values (default: `, `)
	 * @return string The rendered HTML content for the table cell
	 */
	protected function renderTableField(Page $user, string $fieldName, array $params): string {
		/** @var WireArray $rows */
		$rows = $user->get($fieldName);
		$column = $params['table_column'] ?? '';
		$pageField = $params['resolve_page'] ?? '';
		$asLink = !empty($params['as_link']);
		$separator = $params['separator'] ?? ', ';
		$output = [];
	
		// Ensure the field is a WireArray instance
		if (!($rows instanceof WireArray)) return '';
		
		// Check for modal configuration
		$modalContent = $this->renderModal($rows, $params, $fieldName);
		if ($modalContent) {
			return $modalContent;
		}
		
		foreach ($rows as $row) {
			$pageID = (int) ($row[$column] ?? 0);
			if (!$pageID) continue;
	
			$page = wire('pages')->get($pageID);
			if (!$page instanceof Page || !$page->id) continue;
			if ($pageField && !$page->hasField($pageField) && !$page->$pageField) continue;	
					
			$text = ($page->$pageField != '') ? $page->$pageField : $page->title;
			$text = $this->sanitizer->entities((string) $text);
	
			// Generate tooltip if configured
			$tooltip = $this->renderTooltipValue(
				$row[$params['tooltip_field']] ?? null,
				$params
			);
	
			// Construct output as link or plain text
			if ($asLink) {
				$output[] = "<a href='{$page->url}'{$tooltip}>{$text}</a>";
			} else {
				$output[] = "<span{$tooltip}>{$text}</span>";
			}
		}
	
		return implode($separator, $output);
	}
	
	/**
	 * Render a FieldtypePage or PageArray field.
	 *
	 * Outputs the value of a single Page or PageArray field by optionally resolving a subfield,
	 * sanitizing the output, and rendering as plain text or as a link to the Page.
	 *
	 * @param Page $user The user whose field should be rendered
	 * @param string $fieldName The name of the Page or PageArray field
	 * @param array $params Parameters including:
	 *   - resolve_page: Subfield of the referenced Page to output (optional, falls back to name)
	 *   - separator: String to separate multiple values (default: ', ')
	 *   - as_link: Whether to render output as a hyperlink to the referenced Page (optional)
	 * @return string The rendered HTML content for the field
	 */
	protected function renderPageField(Page $user, string $fieldName, array $params): string {
		$resolvePage = trim($params['resolve_page'] ?? '');
		$sep = $params['separator'] ?? ', ';
		$asLink = !empty($params['as_link']);
		$output = [];
	
		$value = $user->get($fieldName);
	
		// Handle multiple Page references
		if ($value instanceof PageArray) {
			foreach ($value as $page) {
				if (!$page instanceof Page) continue;
	
				$fieldValue = $resolvePage !== '' ? $page->get($resolvePage) : $page->name;
				$text = $this->sanitizer->entities(trim((string) $fieldValue));
	
				if ($text !== '') {
					if ($asLink) {
						$output[] = "<a href='{$page->url}'>{$text}</a>";
					} else {
						$output[] = $text;
					}
				}
			}
		}
		// Handle single Page reference
		elseif ($value instanceof Page) {
			$fieldValue = $resolvePage !== '' ? $value->get($resolvePage) : $value->name;
			$text = $this->sanitizer->entities(trim((string) $fieldValue));
	
			if ($text !== '') {
				if ($asLink) {
					$output[] = "<a href='{$value->url}'>{$text}</a>";
				} else {
					$output[] = $text;
				}
			}
		}
	
		return !empty($output) ? implode($sep, $output) : '';
	}

	
	/**
	 * Render a primitive field (string, number, Page, PageArray) from the user object.
	 *
	 * Handles Page and PageArray objects gracefully by optionally resolving a subfield.
	 * Applies optional tooltip and edit link rendering.
	 *
	 * @param Page $user The current user
	 * @param string $fieldName The name of the field to render
	 * @param array $params Rendering parameters, including:
	 *   - resolve_page: Subfield to extract from Page/PageArray (optional)
	 *   - edit_link: Link to user edit page (optional)
	 *   - separator: Separator between multiple values (default: ", ")
	 *   - tooltip_field / tooltip_prefix / tooltip_format: Tooltip configuration (optional)
	 * @return string The rendered output for the field
	 */
	protected function renderPrimitiveField(Page $user, string $fieldName, array $params): string {
		$editLink = !empty($params['edit_link']);
		$sep = $params['separator'] ?? ', ';
		// Get the field value
		$value = $user->get($fieldName);
	
		// Handle Fieldtype Select Options (SelectableOptionArray)
		if ($value instanceof SelectableOptionArray) {
			$labels = [];
			foreach ($value as $option) {
				$labels[] = $option->title; // Get the title of each selected option
			}
			return implode($sep, $labels); // Join the labels with a separator
		}
	
		// Handle other field types (e.g., checkboxes, toggles)
		$field = wire('fields')->get($fieldName);
		if ($field->type instanceof FieldtypeCheckbox || $field->type instanceof FieldtypeToggle) {
			$value = $value == "1" ? 1 : 0; // Normalize checkbox values to 1 or 0
		}
	
		// Format the value using the centralized method
		$output = $this->formatValue($value, $params);
	
		// Render tooltip if configured
		$tooltip = $this->renderTooltipValue(
			$user->get($params['tooltip_field'] ?? null),
			$params
		);
	
		// Render output with optional edit link or tooltip
		if ($editLink) {
			return "<a href='{$user->editUrl}'{$tooltip}>{$output}</a>";
		}
		if ($tooltip) {
			return "<span{$tooltip}>{$output}</span>";
		}
		return $output;
	}

	
	/**
	 * Render a virtual field based on a selector expression.
	 *
	 * Supports aggregate functions (`sum()`, `avg()`, `min()`, `max()`, `count()`, `join(...)`)
	 * and direct access to user properties. Applies optional formatting.
	 *
	 * @param Page $user The current user object
	 * @param string $expr The selector expression (e.g., `sum(products.price)`)
	 * @param array $params Configuration parameters, including:
	 *  - `format`: Output format (`int`, `number`, `currency`, `percent`, `custom=...`)
	 * @return string The rendered content based on the selector expression
	 */
	protected function renderSelectorExpression(Page $user, string $expr, array $params = []): string {
		// Direct access to user property if no function is specified
		if (preg_match('/^[A-Za-z_]\w*$/', $expr)) {
			$raw = $user->{$expr};
			return $this->formatValue($raw, $params);
		}
	
		// Allowed functions: sum(), avg(), min(), max(), count(), join(...)
		if (!preg_match('/^(sum|avg|min|max|count|join)\(([\w\.]+)(?:,\s*[\'"]?(.*?)[\'"]?)?\)$/', $expr, $matches)) {
			return "<span style='color:#b00;'>⚠️ Invalid expression: {$this->sanitizer->entities($expr)}</span>";
		}
	
		$func = $matches[1];
		$fieldPath = $matches[2];
		$joinSep = $matches[3] ?? ', ';
	
		// Resolve nested field path
		$data = $this->resolveNestedField($user, $fieldPath);
		if (!is_array($data)) return '–';
	
		// Filter out non-scalar values
		$data = array_filter($data, fn($v) => is_scalar($v));
	
		$result = null;
	
		// Apply aggregate function
		switch ($func) {
			case 'sum':
				$result = array_sum($data);
				break;
			case 'avg':
				$result = count($data) ? array_sum($data) / count($data) : null;
				break;
			case 'min':
				$result = count($data) ? min($data) : null;
				break;
			case 'max':
				$result = count($data) ? max($data) : null;
				break;
			case 'count':
				$result = count($data);
				break;
			case 'join':
				return implode($joinSep, $data);
		}
	
		if (!isset($result)) return '–';
	
		// Format the result using the centralized method
		return $this->formatValue($result, $params);
	}
	
	/**
	 * Resolve a nested field path for a user.
	 *
	 * Processes a nested field path (e.g., `products.price`) and retrieves the corresponding values.
	 * Supports Page, WireArray, TableRow, and array structures.
	 *
	 * @param Page $user The user object to resolve the field path against
	 * @param string $path The nested field path (e.g., `orders.items.price`)
	 * @return array The resolved values as an array of scalars
	 */
	protected function resolveNestedField(Page $user, string $path): array {
		$parts = explode('.', $path);
		$base = $user->get(array_shift($parts));
	
		// Ensure the base is a WireArray for iteration
		if (!($base instanceof WireArray)) return [];
	
		$output = [];
	
		// Iterate through each row in the WireArray
		foreach ($base as $row) {
			$current = $row;
	
			// Traverse the nested path
			foreach ($parts as $step) {
				if ($current instanceof Wire || $current instanceof Page) {
					$current = $current->get($step);
				} elseif ($current instanceof TableRow && isset($current[$step])) {
					$current = $current[$step];
				} elseif (is_array($current) && isset($current[$step])) {
					$current = $current[$step];
				} else {
					$current = null;
				}
	
				// Resolve numeric IDs to Page objects if not the last step
				if (is_numeric($current) && $step !== end($parts)) {
					$current = wire('pages')->get((int) $current);
				}
	
				if (!$current) break;
			}
	
			// Collect only scalar values for the output
			if (is_scalar($current)) {
				$output[] = $current;
			}
		}
	
		return $output;
	}

	
	/**
	 * Determine how to render a cell based on the field type and configuration parameters.
	 *
	 * This method acts as a dispatcher that directs the rendering to the appropriate method
	 * based on the provided parameters. It handles virtual fields, table fields, Page/PageArray fields,
	 * and primitive fields.
	 *
	 * @param Page $user The current user object
	 * @param string $fieldName The name of the field
	 * @param array $params Configuration parameters for the field
	 * @return string The rendered content for the table cell
	 */
	protected function renderCell(Page $user, string $fieldName, array $params): string {
		$value = $user->get($fieldName);
	
		// 0) Virtual fields (virtual__...) are processed first
		if (str_starts_with($fieldName, 'virtual__') && !empty($params['selector'])) {
			return $this->renderSelectorExpression($user, $params['selector'], $params);
		}
	
		// 1) TableField
		if (!empty($params['table_column'])) {
			return empty($params['resolve_page'])
				? $this->renderTableRawField($user, $fieldName, $params)
				: $this->renderTableField($user, $fieldName, $params);
		}
	
		// 2) Page or PageArray fields
		if ($value instanceof Page || $value instanceof PageArray) {
			return $this->renderPageField($user, $fieldName, $params);
		}
	
		// 3) Primitive fields
		return $this->renderPrimitiveField($user, $fieldName, $params);
	}
	
	
	/**
		 * Render a table column (header or data cell) with optional text alignment and other configuration.
		 *
		 * This method handles both the rendering of header cells (<th>) and data cells (<td>) for the table.
		 * It applies any specified text alignment (left, center, right) using UIKit classes and supports
		 * dynamic content generation for both headers (including sorting links) and data cells.
		 *
		 * @param Page|NullPage|null $user The user object for the current row (null when rendering a header).
		 * @param array $col The column configuration array, including parameters like 'user_field' and 'parameters'.
		 * @param bool $isHeader Whether the column being rendered is a header (<th>) or a data cell (<td>).
		 * @return string The rendered HTML string for the column (<th> or <td>).
		 */
		 protected function renderColumn($user, $col, $isHeader = false): string {
			$field = $col['user_field'] ?? '';
			$params = $this->parseParams($col['parameters'] ?? '');
		
			// Determine text alignment class
			$textAlign = $params['textAlign'] ?? 'left'; // Default to 'left'
			$alignClass = match (strtolower($textAlign)) {
				'center' => 'uk-text-center',
				'right' => 'uk-text-right',
				default => 'uk-text-left',
			};
		
			if ($isHeader) {
				// Render header cell (<th>)
				$label = $params['label'] ?? null;
				if (!$label) {
					$fieldData = wire('fields')->get($field);
					$label = $fieldData instanceof Field ? $fieldData->label : $field;
				}
		
				$sortField = $this->input->get('sort');
				$sortDir = strtolower($this->input->get('dir') ?? 'asc');
				$newDir = ($sortField === $field && $sortDir === 'asc') ? 'desc' : 'asc';
		
				$query = http_build_query([
					'sort' => $field,
					'dir' => $newDir,
					'start' => 0,
				]);
				$url = $this->page->url . '?' . $query;
		
				$sortIcon = '';
				if ($sortField === $field) {
					$icon = $sortDir === 'asc' ? 'chevron-up' : 'chevron-down';
					$sortIcon = "&nbsp;<span uk-icon=\"icon: {$icon}; ratio: 1\" style=\"vertical-align: 2px;\"></span>";
				}
		
				return "<th class='{$alignClass}'><a href='{$url}'>{$this->sanitizer->entities($label)}{$sortIcon}</a></th>";
			} else {
				// Render data cell (<td>)
				$cell = $this->renderCell($user, $field, $params);
				return "<td class='{$alignClass}'>{$cell}</td>";
			}
		}
		
	/**
	  * Render the complete user data table.
	  *
	  * This method fetches users based on role filters, applies sorting and pagination,
	  * and generates a complete HTML table based on the configured field definitions.
	  *
	  * @param array $configData Configuration data passed from the module settings
	  * @return string Rendered HTML table markup
	  */
     protected function renderTable($configData) {
	
		// Build a configuration button
		$moduleName = $this->className();
		$editUrl = $this->wire('config')->urls->admin . "module/edit?name={$moduleName}&collapse_info=1";
		$editlink = "<a class='ui-button ui-widget ui ui-corner-all ui-state-default' href='{$editUrl}'>Configuration</a>";
	
		// Show message if no fields are configured
		if (empty($this->columns)) return '<p>No fields configured.</p>' . $editlink;
	
		// Determine pagination and sorting defaults
		$limit = max(1, (int) ($configData['entries_per_page'] ?? 25));
		$defaultSortField = $configData['sort_field'] ?? 'created';
		$defaultSortDir = $configData['sort_dir'] ?? 'desc';
	
		// Sort field and direction from query string
		$sortField = $this->input->get('sort') ?: $defaultSortField;
		$sortDir = strtolower($this->input->get('dir') ?: $defaultSortDir);
	
		// Ensure valid sort direction
		if (!in_array($sortDir, ['asc', 'desc'])) $sortDir = 'asc';
	
		// Define allowed system fields for sorting
		$systemFields = ['created', 'modified', 'id', 'title'];
	
		// Filter users by roles
		$roles = $configData['user_roles'] ?? [];
		$roleNames = array_map('trim', $roles);
		$users = new PageArray();
	
		if (!empty($roleNames)) {
			if (($configData['roles_mode'] ?? 'or') === 'and') {
				// AND Mode: User must have exactly all selected roles
				$requiredRoleIDs = [];
				foreach ($roleNames as $name) {
					$role = wire('roles')->get($name);
					if ($role) $requiredRoleIDs[] = (int) $role->id;
				}
				sort($requiredRoleIDs);
				$selector = "roles.name=" . implode('|', $roleNames);
				$allUsers = $this->users->find($selector);
	
				$filtered = array_filter($allUsers->getArray(), function($user) use ($requiredRoleIDs) {
					$userRoleIDs = array_map('intval', $user->roles->explode('id'));
					sort($userRoleIDs);
					return $userRoleIDs === $requiredRoleIDs;
				});
	
				foreach ($filtered as $u) $users->add($u);
	
			} else {
				// OR Mode: User must have at least one of the selected roles
				$selector = "roles.name=" . implode('|', $roleNames);
				$users = $this->users->find($selector);
			}
		} else {
			// No filter: all users with any role
			$users = $this->users->find("roles.name!=");
		}
	
		if (!count($users)) return '<p>No users found.</p>';
	
		// Collect all valid sort fields
		$validSortFields = array_merge(array_column($this->columns, 'user_field'), $systemFields);
	
		// Apply sorting
		if ($sortField && in_array($sortField, $validSortFields)) {
			$usersArray = $users->getArray();
	
			// Special case: virtual column sorting
			if (str_starts_with($sortField, 'virtual__')) {
				$params = $this->parseParams($configData['param__' . $sortField] ?? '');
				$expr = $params['selector'] ?? '';
	
				usort($usersArray, function($a, $b) use ($sortDir, $params, $expr) {
					$valA = $this->renderSelectorExpression($a, $expr, $params);
					$valB = $this->renderSelectorExpression($b, $expr, $params);
					return $sortDir === 'desc'
						? strnatcasecmp($valB, $valA)
						: strnatcasecmp($valA, $valB);
				});
	
			} else {
				// Sorting for both user-defined fields and system fields
				usort($usersArray, function($a, $b) use ($sortField, $sortDir) {
					$valA = $a->getUnformatted($sortField);
					$valB = $b->getUnformatted($sortField);
	
					$valA = is_object($valA) ? (string) $valA : $valA;
					$valB = is_object($valB) ? (string) $valB : $valB;
	
					$result = strnatcasecmp((string) $valA, (string) $valB);
					return $sortDir === 'desc' ? -$result : $result;
				});
			}
	
			// Reassign the sorted array to the users collection
			$users = new PageArray();
			foreach ($usersArray as $u) $users->add($u);
		}
	
		// Pagination
		$total = count($users);
		$start = max(0, (int) $this->input->get('start') ?? 0);
		$pageNum = floor($start / $limit) + 1;
		$pagedUsers = $users->slice($start, $limit);
	
		// Begin table output
		$out = "<div class='pw-table-responsive uk-overflow-auto'>";
		$out .= "<table id='UserDataTable' class='AdminDataTable AdminDataList AdminDataTableSortable uk-table uk-table-divider uk-table-justify uk-table-small tablesorter' role='grid'>";
		$out .= "<thead><tr role='row' class='tablesorter-headerRow'>";
	
		// Table headers
		foreach ($this->columns as $col) {
			$out .= $this->renderColumn(null, $col, true);
		}
		$out .= "</tr></thead>";
	
		// Table rows
		$out .= "<tbody>";
		foreach ($pagedUsers as $user) {
			$out .= "<tr role='row'>";
			foreach ($this->columns as $col) {
				$out .= $this->renderColumn($user, $col);
			}
			$out .= "</tr>";
		}
		$out .= "</tbody></table></div>";
	
		// Pagination links
		if ($total > $limit) {
			$pageCount = ceil($total / $limit);
			$out .= "<ul class='uk-pagination'>";
			for ($i = 1; $i <= $pageCount; $i++) {
				$class = $i == $pageNum ? 'uk-active' : '';
				$startVal = ($i - 1) * $limit;
				$query = http_build_query([
					'sort' => $sortField,
					'dir' => $sortDir,
					'start' => $startVal,
				]);
				$url = $this->page->url . '?' . $query;
				$out .= "<li class='{$class}'><a href='{$url}'>{$i}</a></li>";
			}
			$out .= "</ul>";
		}
	
		return $out . $editlink;
	}
	

/**
	 * Generate the configuration input fields for the module.
	 *
	 * This method dynamically creates the input fields for the module's configuration,
	 * including user-defined fields, sorting options, roles filtering, and per-column
	 * configuration parameters. Each field is built based on its configuration schema,
	 * and all user/extra fields are aggregated for additional column-specific settings.
	 * 
	 * The column-specific settings are configured via textareas, allowing options such as:
	 * - `textAlign`: Controls the text alignment (`left`, `center`, `right`).
	 * - `label`: Customizes the column label.
	 * Additional key-value pairs can be defined per line.
	 *
	 * @param array $data The current module configuration data.
	 * @return InputfieldWrapper The wrapper containing all input fields for configuration.
	 */

public static function getModuleConfigInputfields(array $data): InputfieldWrapper {
	$inputfields = new InputfieldWrapper();

	// Define a schema for the configuration fields
	$configFields = [
		'user_fields_select' => [
			'type'        => 'InputfieldAsmSelect',
			'label'       => 'Fields from the User Template',
			'description' => 'Select fields from the User template to be displayed in the table.',
			'options'     => self::getUserTemplateFields(),
			'value'       => $data['user_fields_select'] ?? [],
			'columnWidth' => 50,
		],
		'extra_fields' => [
			'type'        => 'InputfieldText',
			'label'       => 'Additional (virtual) field names',
			'description' => 'Comma-separated, e.g., virtual__sum, virtual__avgScore.',
			'value'       => $data['extra_fields'] ?? '',
			'columnWidth' => 50,
		],
		'user_roles' => [
			'type'        => 'InputfieldAsmSelect',
			'label'       => 'Show only users with the following roles',
			'description' => 'If no role is selected, all users will be displayed.',
			'options'     => self::getAvailableRoles(),
			'value'       => $data['user_roles'] ?? [],
			'columnWidth' => 50,
		],
		'roles_mode' => [
			'type'        => 'InputfieldRadios',
			'label'       => 'Role condition',
			'description' => 'At least one (OR) or all exactly (AND)',
			'options'     => ['or' => 'At least one (OR)', 'and' => 'All exactly (AND)'],
			'value'       => $data['roles_mode'] ?? 'or',
			'columnWidth' => 50,
		],
		'sort_field' => [
			'type'        => 'InputfieldText',
			'label'       => 'Default sorting field',
			'description' => 'e.g., "email" or "virtual__sum".',
			'value'       => $data['sort_field'] ?? '',
			'columnWidth' => 40,
		],
		'sort_dir' => [
			'type'        => 'InputfieldSelect',
			'label'       => 'Sorting direction',
			'description' => '"Ascending": A->Z, or 1->100.',
			'options'     => ['asc' => 'Ascending', 'desc' => 'Descending'],
			'value'       => $data['sort_dir'] ?? 'asc',
			'columnWidth' => 40,
		],
		'entries_per_page' => [
			'type'        => 'InputfieldInteger',
			'label'       => 'Entries per page',
			'description' => 'Default: 25',
			'value'       => $data['entries_per_page'] ?? 25,
			'columnWidth' => 20,
		],
	];

	// Generate input fields dynamically based on the schema
	foreach ($configFields as $name => $fieldConfig) {
		$field = wire('modules')->get($fieldConfig['type']);
		$field->name = $name;
		$field->label = $fieldConfig['label'];
		$field->description = $fieldConfig['description'];
		$field->value = $fieldConfig['value'];
		if (isset($fieldConfig['options'])) {
			$field->addOptions($fieldConfig['options']);
		}
		if (isset($fieldConfig['columnWidth'])) {
			$field->columnWidth = $fieldConfig['columnWidth'];
		}
		$inputfields->add($field);
	}

	// Generate hidden field for combined list of user/extra fields
	$allFields = array_merge(
		$data['user_fields_select'] ?? [],
		array_map('trim', explode(',', $data['extra_fields'] ?? ''))
	);

	$hiddenField = wire('modules')->get('InputfieldHidden');
	$hiddenField->name = 'user_fields';
	$hiddenField->value = json_encode($allFields);
	$inputfields->add($hiddenField);

	// Add parameter textareas for each field with default values based on field type
	foreach ($allFields as $fieldName) {
		$fieldName = trim($fieldName);
		if (!$fieldName) continue;

		// Determine default value for the CONFIG textarea based on the field type
		$defaultConfig = self::getDefaultConfigForField($fieldName);

		$paramField = wire('modules')->get('InputfieldTextarea');
		$paramField->name = 'param__' . $fieldName;
		$paramField->label = sprintf('Parameters for column "%s"', $fieldName);
		$paramField->description = 'Optional: key=value per line';
		$paramField->value = $data['param__' . $fieldName] ?? $defaultConfig; // Populate with default values if not set
		$paramField->rows = 7;
		$paramField->columnWidth = 33;

		// Add notes based on the field type
		$paramField->notes = self::getFieldNotes($fieldName);

		$inputfields->add($paramField);
	}

	return $inputfields;
}

/**
 * Helper function to determine default configuration values for fields based on their type.
 *
 * @param string $fieldName The name of the field.
 * @return string The default configuration for this field.
 */
/* private static function getDefaultConfigForField(string $fieldName): string {
	 if (str_starts_with($fieldName, 'virtual__')) {
		 return "label=Virtual Field (optional)\n"
			 . "textAlign=left\n"
			 . "format=int|number|currency|percent|custom=...\n"
			 . "locale=en_US (optional)\n" // Added locale
			 . "separator=, (optional)\n"
			 . "tooltip_field=... (optional)\n"
			 . "tooltip_prefix=... (optional)";
	 }
 
	 $field = wire('fields')->get($fieldName);
	 if ($field instanceof Field && strpos(get_class($field->type), 'FieldtypeTable') !== false) {
		 return "label=Table Field (optional)\n"
			 . "table_column=... (**Required**)\n"
			 . "textAlign=left\n"
			 . "resolve_page=... (optional)\n"
			 . "as_link=1 (optional)\n"
			 . "separator=, (optional)\n"
			 . "tooltip_field=... (optional)\n"
			 . "tooltip_prefix=... (optional)\n"
			 . "tooltip_format=date(format) (optional)";
	 }
 
	 if ($field instanceof Field && strpos(get_class($field->type), 'FieldtypePage') !== false) {
		 return "label=Page Field (optional)\n"
			 . "resolve_page=... (**Required**)\n"
			 . "textAlign=left\n"
			 . "as_link=1 (optional)\n"
			 . "separator=, (optional)\n"
			 . "tooltip_field=... (optional)\n"
			 . "tooltip_prefix=... (optional)\n"
			 . "tooltip_format=date(format) (optional)";
	 }
 
	 // Default for primitive fields
	 return "label=Primitive Field (optional)\n"
		 . "textAlign=left\n"
		 . "format=int|number|currency|percent|custom=...\n" // Added format
		 . "locale=en_US (optional)\n" // Added locale
		 . "edit_link=1 (optional)\n"
		 . "separator=, (optional)\n"
		 . "tooltip_field=... (optional)\n"
		 . "tooltip_prefix=... (optional)\n"
		 . "tooltip_format=date(format)|map(1=No,2=Yes) (optional)";
 } */

private static function getDefaultConfigForField(string $fieldName): string {
	if (str_starts_with($fieldName, 'virtual__')) {
		return "label=STRING (optional)\n"
			. "textAlign=left | center | right\n"
			. "separator=STRING (optional)\n"
			. "format=...(optional)\n"
			. "tooltip_field=FIELDNAME (optional)\n"
			. "tooltip_prefix=STRING (optional)\n"
			. "tooltip_format=... (optional)\n";
	}

	$field = wire('fields')->get($fieldName);

	if ($field instanceof Field && strpos(get_class($field->type), 'FieldtypeTable') !== false) {
		return "label=STRING (optional)\n"
			. "table_column=NAME (**Required**)\n"
			. "textAlign=left | center | right\n"
			. "resolve_page=FIELDNAME (optional)\n"
			. "as_link=1 (optional)\n"
			. "separator=STRING (optional)\n"
			. "format=...(optional)\n"
			. "tooltip_field=FIELDNAME (optional)\n"
			. "tooltip_prefix=STRING (optional)\n"
			. "tooltip_format=... (optional)\n";
	}

	if ($field instanceof Field && strpos(get_class($field->type), 'FieldtypePage') !== false) {
		return "label=STRING (optional)\n"
			. "resolve_page=FIELDNAME (**Required**)\n"
			. "textAlign=left | center | right\n"
			. "as_link=1 (optional)\n"
			. "separator=STRING (optional)\n"
			. "format=...(optional)\n"
			. "tooltip_field=FIELDNAME (optional)\n"
			. "tooltip_prefix=STRING (optional)\n"
			. "tooltip_format=... (optional)\n";
	}

	// Default for primitive fields
	return "label=STRING (optional)\n"
		. "textAlign=left | center | right\n"
		. "format=...(optional)\n"
		. "edit_link=1 (optional)\n"
		. "separator=STRING (optional)\n"
		. "tooltip_field=FIELDNAME (optional)\n"
		. "tooltip_prefix=STRING (optional)\n"
		. "tooltip_format=... (optional)\n";
}
	
	// Helper function to generate notes based on field type
	private static function getFieldNotes(string $fieldName): string {
		if (str_starts_with($fieldName, 'virtual__')) {
			return "**Virtual Fields**\n"
				. "- `selector=...` (e.g., `sum(products.product_id.price)`)\n"
				. "- `label=STRING` (optional)\n"
				. "- `textAlign=left | center | right` (optional, default: `left`)\n"
				. "- `separator=STRING` (optional, Default: `, `)\n"
				. "- `format=...` (optional)\n"
				. "- `tooltip_field=FIELDNAME` (optional)\n"
				. "- `tooltip_prefix=STRING` (optional)\n"
				. "- `tooltip_format=...` (optional)\n"
				. "FORMATTING OPTIONS: int | number | percent | currency(CODE:LOCALE) | date(FORMAT) | map(KEY:VALUE,...) | custom(SPRINTF)\n";
		}
	
		$field = wire('fields')->get($fieldName);
	
		if ($field instanceof Field && strpos(get_class($field->type), 'FieldtypeTable') !== false) {
			return "**TableField**\n"
				. "- `label=STRING` (optional)\n"
				. "- `table_column=NAME` (**Required**)\n"
				. "- `textAlign=left | center | right` (optional, default: `left`)\n"
				. "- `resolve_page=FIELDNAME` (optional)\n"
				. "- `as_link=1` (optional)\n"
				. "- `separator=STRING` (optional)\n"
				. "- `format=...` (optional)\n"
				. "- `tooltip_field=FIELDNAME` (optional)\n"
				. "- `tooltip_prefix=STRING` (optional)\n"
				. "- `tooltip_format=...` (optional)\n"
				. "FORMATTING OPTIONS: int | number | percent | currency(CODE:LOCALE) | date(FORMAT) | map(KEY:VALUE,...) | custom(SPRINTF)\n";
		}
	
		if ($field instanceof Field && strpos(get_class($field->type), 'FieldtypePage') !== false) {
			return "**PageField**\n"
				. "- `label=STRING` (optional)\n"
				. "- `resolve_page=FIELDNAME` (**Required**)\n"
				. "- `textAlign=left | center | right` (optional, default: `left`)\n"
				. "- `as_link=1` (optional)\n"
				. "- `separator=STRING` (optional)\n"
				. "- `format=...` (optional)\n"
				. "- `tooltip_field=FIELDNAME` (optional)\n"
				. "- `tooltip_prefix=STRING` (optional)\n"
				. "- `tooltip_format=...` (optional)\n"
				. "FORMATTING OPTIONS: int | number | percent | currency(CODE:LOCALE) | date(FORMAT) | map(KEY:VALUE,...) | custom(SPRINTF)\n";
		}
	
		// Default for primitive fields
		return "**Primitive Fields**\n"
			. "- `label=STRING` (optional)\n"
			. "- `textAlign=left | center | right` (optional, default: `left`)\n"
			. "- `format=...` (optional)\n"
			. "- `edit_link=1` (optional)\n"
			. "- `separator=STRING` (optional)\n"
			. "- `tooltip_field=FIELDNAME` (optional)\n"
			. "- `tooltip_prefix=STRING` (optional)\n"
			. "- `tooltip_format=...` (optional)\n"
			. "FORMATTING OPTIONS: int | number | percent | currency(CODE:LOCALE) | date(FORMAT) | map(KEY:VALUE,...) | custom(SPRINTF)\n";
	}
	
	// Helper function to fetch user template fields
	private static function getUserTemplateFields(): array {
		$userTemplate = wire('templates')->get('user');
		$fieldOptions = [];
		foreach ($userTemplate->fields as $field) {
			$fieldOptions[$field->name] = $field->label;
		}
		return $fieldOptions;
	}
	
	// Helper function to fetch available roles
	private static function getAvailableRoles(): array {
		$roleOptions = [];
		foreach (wire('roles') as $role) {
			$roleOptions[$role->name] = $role->name;
		}
		return $roleOptions;
	}
	
}
